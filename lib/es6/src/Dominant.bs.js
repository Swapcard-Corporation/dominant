// Generated by BUCKLESCRIPT VERSION 2.1.0, PLEASE EDIT WITH CARE
'use strict';

import * as $$Array         from "bs-platform/lib/es6/array.js";
import * as Caml_array      from "bs-platform/lib/es6/caml_array.js";
import * as Pervasives      from "bs-platform/lib/es6/pervasives.js";
import * as Webapi$Dominant from "./Webapi.bs.js";

function reduceRange(color, range) {
  return /* float array */[
          Pervasives.min(color, range[/* min */0]),
          Pervasives.max(color, range[/* max */1])
        ];
}

function reduceColorRange(pixel, ranges, _) {
  if (ranges) {
    var ranges$1 = ranges[0];
    return /* record */[
            /* red */reduceRange(pixel[/* red */0], ranges$1[/* red */0]),
            /* green */reduceRange(pixel[/* green */1], ranges$1[/* green */1]),
            /* blue */reduceRange(pixel[/* blue */2], ranges$1[/* blue */2])
          ];
  } else {
    return /* record */[
            /* red : float array */[
              pixel[/* red */0],
              pixel[/* red */0]
            ],
            /* green : float array */[
              pixel[/* green */1],
              pixel[/* green */1]
            ],
            /* blue : float array */[
              pixel[/* blue */2],
              pixel[/* blue */2]
            ]
          ];
  }
}

function ofColor(red, green, blue, _) {
  return /* float array */[
          red,
          green,
          blue
        ];
}

function ofFloatArray(colorArray) {
  var _position = 0;
  var _acc = /* array */[];
  while(true) {
    var acc = _acc;
    var position = _position;
    if ((position + 3 | 0) < colorArray.length) {
      _acc = $$Array.append(acc, /* array */[(Caml_array.caml_array_get(colorArray, position + 3 | 0), /* float array */[
                Caml_array.caml_array_get(colorArray, position + 0 | 0),
                Caml_array.caml_array_get(colorArray, position + 1 | 0),
                Caml_array.caml_array_get(colorArray, position + 2 | 0)
              ])]);
      _position = position + 4 | 0;
      continue ;
      
    } else {
      return acc;
    }
  };
}

function getRange(pixelArray) {
  return $$Array.fold_left((function (ranges, pixel) {
                return /* Some */[reduceColorRange(pixel, ranges, /* () */0)];
              }), /* None */0, pixelArray);
}

function sortPixelList(pixelArray, colorRange) {
  var deltaRed = colorRange[/* red */0][/* max */1] - colorRange[/* red */0][/* min */0];
  var deltaGreen = colorRange[/* green */1][/* max */1] - colorRange[/* green */1][/* min */0];
  var deltaBlue = colorRange[/* blue */2][/* max */1] - colorRange[/* blue */2][/* min */0];
  if (deltaRed > deltaGreen && deltaRed > deltaBlue) {
    var sortFn = function (l, r) {
      return l[/* red */0] - r[/* red */0] | 0;
    };
    return $$Array.sort(sortFn, pixelArray);
  } else if (deltaGreen > deltaBlue && deltaGreen > deltaRed) {
    var sortFn$1 = function (l, r) {
      return l[/* green */1] - r[/* green */1] | 0;
    };
    return $$Array.sort(sortFn$1, pixelArray);
  } else {
    var sortFn$2 = function (l, r) {
      return l[/* blue */2] - r[/* blue */2] | 0;
    };
    return $$Array.sort(sortFn$2, pixelArray);
  }
}

function colorAverage(pixelArray) {
  var squaredPixelArray = $$Array.map((function (c) {
          return /* float array */[
                  c[/* red */0] * c[/* red */0],
                  c[/* green */1] * c[/* green */1],
                  c[/* blue */2] * c[/* blue */2]
                ];
        }), pixelArray);
  var squaredPixelsSum = $$Array.fold_left((function (v, a) {
          return /* float array */[
                  v[/* red */0] + a[/* red */0],
                  v[/* green */1] + a[/* green */1],
                  v[/* blue */2] + a[/* blue */2]
                ];
        }), /* float array */[
        0,
        0,
        0
      ], squaredPixelArray);
  return /* float array */[
          Math.sqrt(squaredPixelsSum[/* red */0] / pixelArray.length),
          Math.sqrt(squaredPixelsSum[/* green */1] / pixelArray.length),
          Math.sqrt(squaredPixelsSum[/* blue */2] / pixelArray.length)
        ];
}

function clusterize(pixelArray, square) {
  var _clusters = /* array */[pixelArray];
  var _square = square;
  while(true) {
    var square$1 = _square;
    var clusters = _clusters;
    if (square$1) {
      _square = square$1 - 1 | 0;
      _clusters = $$Array.fold_left($$Array.append, /* array */[], $$Array.map((function (cluster) {
                  var range = getRange(cluster);
                  if (range) {
                    sortPixelList(cluster, range[0]);
                    return /* array */[
                            $$Array.sub(cluster, 0, (cluster.length >> 1)),
                            $$Array.sub(cluster, (cluster.length >> 1), (cluster.length >> 1))
                          ];
                  } else {
                    return /* array */[cluster];
                  }
                }), clusters));
      continue ;
      
    } else {
      return clusters;
    }
  };
}

function paletteOfClusters(clusters) {
  return $$Array.map(colorAverage, clusters);
}

function paletteOfPixelArray(pixelArray, $staropt$star, _) {
  var square = $staropt$star ? $staropt$star[0] : 4;
  var clusters = clusterize(pixelArray, square);
  return $$Array.map(colorAverage, clusters);
}

function ofImageData(imageData, square, _) {
  return paletteOfPixelArray(ofFloatArray(imageData.data), square, /* () */0);
}

function ofUrl(url, square, _) {
  return Webapi$Dominant.imageDataOfUrl(url).then((function (imageData) {
                return Promise.resolve(ofImageData(imageData, square, /* () */0));
              }));
}

export {
  reduceRange         ,
  reduceColorRange    ,
  ofColor             ,
  ofFloatArray        ,
  getRange            ,
  sortPixelList       ,
  colorAverage        ,
  clusterize          ,
  paletteOfClusters   ,
  paletteOfPixelArray ,
  ofImageData         ,
  ofUrl               ,
  
}
/* No side effect */
